package codegen

import (
	"fmt"
	"github.com/dave/jennifer/jen"
	"io"
	"lambdagen/internal/model"
)

type GenerationState struct {
	File      *jen.File
	Model     model.LambdaModel
	Variables map[string]string
}

const (
	VariableHandler = "handler"
	VariableRequest = "request"
)

func Transform(writer io.Writer, model model.LambdaModel) error {
	unit := jen.NewFile("main")

	// make our lambda
	unit.HeaderComment("Code generated by lambdagen. DO NOT EDIT.")

	// create state
	genState := &GenerationState{
		File:      unit,
		Model:     model,
		Variables: map[string]string{},
	}

	genState.formatSharedState()
	genState.formatInitFunc()
	genState.formatLambdaHandler()
	genState.formatMainFunc()

	// write our unit
	return unit.Render(writer)
}

// formatSharedState creates any pre-amble variables used globally in the lambda handler
func (state *GenerationState) formatSharedState() *GenerationState {
	// create the handler variable
	handlerVarName := "handler"
	state.File.Var().Id(handlerVarName).Op("*").Qual(state.Model.HandlerType.Package, state.Model.HandlerType.Name)

	// save the handler variable
	state.Variables[VariableHandler] = handlerVarName

	return state
}

func (state *GenerationState) formatInitFunc() *GenerationState {

	cfgVar := "cfg"

	// call
	state.File.Func().Id("init").Params().Block(
		// make a common error variable
		jen.Var().Err().Error(),

		// load the AWS config
		jen.List(jen.Id(cfgVar), jen.Err()).Op(":=").Qual("github.com/aws/aws-sdk-go-v2/config", "LoadDefaultConfig").Call(jen.Qual("context", "TODO").Call()),
		checkErrorPanic(),

		// assign the handler
		jen.List(jen.Id(state.Variables[VariableHandler]), jen.Err()).Op("=").Qual(state.Model.InitFunc.Package, state.Model.InitFunc.Name).Call(jen.Id(cfgVar)),
		checkErrorPanic(),
	)

	return state
}

func (state *GenerationState) formatLambdaHandler() *GenerationState {

	ctxParam := "ctx"
	requestParam := "request"

	state.Variables[VariableRequest] = requestParam

	state.File.Func().Id("HandleRequest").Params(
		// context parameter
		jen.Id(ctxParam).Qual("context", "Context"),
		// API gateway request
		jen.Id(requestParam).Qual("github.com/aws/aws-lambda-go/events", "APIGatewayProxyRequest"),
	).Parens(
		jen.List(jen.Qual("github.com/aws/aws-lambda-go/events", "APIGatewayProxyResponse"), jen.Error()),
	).BlockFunc(func(group *jen.Group) {
		// first, path variables
		requestVarName := "request"
		resultVarName := "result"

		// TODO also need to pass request var type
		createRequestPayload(state, group, requestVarName)

		// Next, call the actual handler
		group.List(jen.Id(resultVarName), jen.Err()).Op(":=").Id(state.Variables[VariableHandler]).Dot(state.Model.HandlerFunc).Call(
			jen.Id(ctxParam), jen.Id(requestVarName),
		)
		buildCheckError(group, failStrategyPanic)

		// marshall the body to a byte buffer
		resultBodyVarName := "resultPayload"
		group.List(jen.Id(resultBodyVarName), jen.Err()).Op(":=").Qual("encoding/json", "Marshal").Call(jen.Id(resultVarName))
		buildCheckError(group, failStrategyPanic)

		group.Return(jen.List(
			jen.Qual("github.com/aws/aws-lambda-go/events", "APIGatewayProxyResponse").Values(jen.Dict{
				jen.Id("StatusCode"): jen.Lit(200),
				jen.Id("Body"):       jen.String().Parens(jen.Id(resultBodyVarName)),
			}),
			jen.Nil(),
		))
	})

	return state
}

func createRequestPayload(state *GenerationState, group *jen.Group, requestVarName string) {

	// mappings
	var fieldVars map[string]string

	// generate code for each path variable
	for _, pathVar := range state.Model.Config.PathVariables {
		pathVariableName := ""
		fieldVars[pathVar.FieldName] = pathVariableName
	}

	if len(state.Model.Config.RequestBody.Name) > 0 {
		bodyVar := "requestBody"
		// TODO probably is bad to do this...
		bodyName := model.NewQualifiedName(state.Model.Config.RequestBody.Type, "")
		createRequestBodyVariable(state, group, bodyVar, bodyName)

		fieldVars[state.Model.Config.RequestBody.FieldName] = bodyVar
	}

	// we know how to fill the field, so create
	requestBodyName := model.NewQualifiedName(state.Model.Config.RequestBody.Type, "")
	group.Id(requestVarName).Op(":=").Qual(requestBodyName.Package, requestBodyName.Name).Values(jen.DictFunc(func(dict jen.Dict) {
		for field, variableName := range fieldVars {
			dict[jen.Id(field)] = jen.Lit(variableName)
		}
	}))
}

func createPathParamVariable(state *GenerationState, group *jen.Group, variableName string, tp model.VariableTp) {
	presentName := "present"
	rawVarName := fmt.Sprintf("%sRaw", variableName)

	// access the param
	group.List(jen.Id(rawVarName), jen.Id(presentName)).Op(":=").Id(state.Variables[VariableRequest]).Dot("PathParameters").Index(jen.Lit(variableName))

	// figure out what to do if the thing is missing
	group.If(jen.Op("!").Id(presentName)).Block(
		jen.Panic(jen.Lit("variable is missing")),
	)

	// build any conversion code
	ConversionCode(group, tp, rawVarName, variableName)
}

func createRequestBodyVariable(state *GenerationState, group *jen.Group, bodyVar string, bodyTp model.QualifiedName) {
	// make the variable and unmarshal the body
	bodyPayloadName := "bodyBytes"
	group.Var().Id(bodyVar).Qual(bodyTp.Package, bodyTp.Name)
	group.Id(bodyPayloadName).Op(":=").Index().Byte().Parens(jen.Id(state.Variables[VariableRequest]).Dot("Body"))
	group.Err().Op("=").Qual("encoding/json", "Unmarshal").Call(jen.Id(bodyPayloadName), jen.Op("&").Id(bodyVar))
	checkErrorPanic()
}

func (state *GenerationState) formatMainFunc() {
	state.File.Func().Id("main").Params().Block(
		jen.Qual("github.com/aws/aws-lambda-go/lambda", "Start").Call(jen.Id("HandleRequest")),
	)
}
